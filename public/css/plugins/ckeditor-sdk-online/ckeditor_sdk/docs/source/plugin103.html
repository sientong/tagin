<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&#39;use strict&#39;;
CKEDITOR.plugins.add(&#39;scayt&#39;, {

	//requires : [&#39;menubutton&#39;, &#39;dialog&#39;],
	requires: &#39;menubutton,dialog&#39;,
	lang: &#39;af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh&#39;, // %REMOVE_LINE_CORE%
	icons: &#39;scayt&#39;, // %REMOVE_LINE_CORE%
	hidpi: true, // %REMOVE_LINE_CORE%
	tabToOpen : null,
	dialogName: &#39;scaytDialog&#39;,
	init: function(editor) {
		var self = this,
			plugin = CKEDITOR.plugins.scayt;

		this.bindEvents(editor);
		this.parseConfig(editor);
		this.addRule(editor);

		// source mode
		CKEDITOR.dialog.add(this.dialogName, CKEDITOR.getUrl(this.path + &#39;dialogs/options.js&#39;));
		// end source mode

		this.addMenuItems(editor);
		var config = editor.config,
			lang = editor.lang.scayt,
			env = CKEDITOR.env;

		editor.ui.add(&#39;Scayt&#39;, CKEDITOR.UI_MENUBUTTON, {
			label : lang.text_title,
			title : ( editor.plugins.wsc ? editor.lang.wsc.title : lang.text_title ),
			// SCAYT doesn&#39;t work in IE Compatibility Mode and IE (8 &amp; 9) Quirks Mode
			modes : {wysiwyg: !(env.ie &amp;&amp; ( env.version &lt; 8 || env.quirks ) ) },
			toolbar: &#39;spellchecker,20&#39;,
			refresh: function() {
				var buttonState = editor.ui.instances.Scayt.getState();

				// check if scayt is created
				if(editor.scayt) {
					// check if scayt is enabled
					if(plugin.state[editor.name]) {
						buttonState = CKEDITOR.TRISTATE_ON;
					} else {
						buttonState = CKEDITOR.TRISTATE_OFF;
					}
				}

				editor.fire(&#39;scaytButtonState&#39;, buttonState);
			},
			onRender: function() {
				var that = this;

				editor.on(&#39;scaytButtonState&#39;, function(ev) {
					if(typeof ev.data !== undefined) {
						that.setState(ev.data);
					}
				});
			},
			onMenu : function() {
				var scaytInstance = editor.scayt;

				editor.getMenuItem(&#39;scaytToggle&#39;).label = editor.lang.scayt[(scaytInstance ? plugin.state[editor.name] : false) ? &#39;btn_disable&#39; : &#39;btn_enable&#39;];

				// If UI tab is disabled we shouldn&#39;t show menu item
				var menuDefinition = {
					scaytToggle  : CKEDITOR.TRISTATE_OFF,
					scaytOptions : scaytInstance ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED,
					scaytLangs   : scaytInstance ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED,
					scaytDict    : scaytInstance ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED,
					scaytAbout   : scaytInstance ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED,
					WSC          : editor.plugins.wsc ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED
				};

				if(!editor.config.scayt_uiTabs[0]) {
					delete menuDefinition.scaytOptions;
				}

				if(!editor.config.scayt_uiTabs[1]) {
					delete menuDefinition.scaytLangs;
				}

				if(!editor.config.scayt_uiTabs[2]) {
					delete menuDefinition.scaytDict;
				}

				return menuDefinition;
			}
		});

		// If the &#39;contextmenu&#39; plugin is loaded, register the listeners.
		if(editor.contextMenu &amp;&amp; editor.addMenuItems) {
			editor.contextMenu.addListener(function(element, selection) {
				var scaytInstance = editor.scayt;
				var result;

				if(scaytInstance) {
					// TODO: implement right lang getter
					var selectionNode = scaytInstance.getSelectionNode(),
						word;

					if(selectionNode) {
						word = selectionNode.getAttribute(scaytInstance.getNodeAttribute());
					} else {
						word = selectionNode;
					}

					// SCAYT shouldn&#39;t build context menu if instance isnot created or word is without misspelling
					if(word) {
						var items = self.menuGenerator(editor, word, self);

						scaytInstance.showBanner(&#39;.&#39; + editor.contextMenu._.definition.panel.className.split(&#39; &#39;).join(&#39; .&#39;));
						result = items;
					}
				}

				return result;
			});

			editor.contextMenu._.onHide = CKEDITOR.tools.override(editor.contextMenu._.onHide, function(org) {
				return function() {
					var scaytInstance = editor.scayt;

					if(scaytInstance) {
						scaytInstance.hideBanner();
					}

					return org.apply(this);
				};
			});
		}
	},
	addMenuItems: function(editor) {
		var self = this,
			plugin = CKEDITOR.plugins.scayt,
			menuGroup = &#39;scaytButton&#39;;

		editor.addMenuGroup(menuGroup);

		var items_order = editor.config.scayt_contextMenuItemsOrder.split(&#39;|&#39;);

		if(items_order &amp;&amp; items_order.length) {
			for(var pos = 0 ; pos &lt; items_order.length ; pos++) {
				editor.addMenuGroup(&#39;scayt_&#39; + items_order[pos], pos - 10);
			}
		}

		editor.addCommand( &#39;scaytToggle&#39;, {
			exec: function(editor) {
				var scaytInstance = editor.scayt;

				plugin.state[editor.name] = !plugin.state[editor.name];

				if(plugin.state[editor.name] === true) {
					if(!scaytInstance) {
						plugin.createScayt(editor);
					}
				} else {
					if(scaytInstance) {
						plugin.destroy(editor);
					}
				}
			}
		} );

		editor.addCommand( &#39;scaytAbout&#39;, {
			exec: function(editor) {
				var scaytInstance = editor.scayt;

				scaytInstance.tabToOpen = &#39;about&#39;;
				editor.lockSelection();
				editor.openDialog(self.dialogName);
			}
		} );

		editor.addCommand( &#39;scaytOptions&#39;, {
			exec: function(editor) {
				var scaytInstance = editor.scayt;

				scaytInstance.tabToOpen = &#39;options&#39;;
				editor.lockSelection();
				editor.openDialog(self.dialogName);
			}
		} );

		editor.addCommand( &#39;scaytLangs&#39;, {
			exec: function(editor) {
				var scaytInstance = editor.scayt;

				scaytInstance.tabToOpen = &#39;langs&#39;;
				editor.lockSelection();
				editor.openDialog(self.dialogName);
			}
		} );

		editor.addCommand( &#39;scaytDict&#39;, {
			exec: function(editor) {
				var scaytInstance = editor.scayt;

				scaytInstance.tabToOpen = &#39;dictionaries&#39;;
				editor.lockSelection();
				editor.openDialog(self.dialogName);
			}
		} );

		var uiMenuItems = {
			scaytToggle: {
				label : editor.lang.scayt.btn_enable,
				group : menuGroup,
				command: &#39;scaytToggle&#39;
			},
			scaytAbout: {
				label : editor.lang.scayt.btn_about,
				group : menuGroup,
				command: &#39;scaytAbout&#39;
			},
			scaytOptions: {
				label : editor.lang.scayt.btn_options,
				group : menuGroup,
				command: &#39;scaytOptions&#39;
			},
			scaytLangs: {
				label : editor.lang.scayt.btn_langs,
				group : menuGroup,
				command: &#39;scaytLangs&#39;
			},
			scaytDict: {
				label : editor.lang.scayt.btn_dictionaries,
				group : menuGroup,
				command: &#39;scaytDict&#39;
			}
		};

		if(editor.plugins.wsc) {
			uiMenuItems.WSC = {
				label : editor.lang.wsc.toolbar,
				group : menuGroup,
				onClick: function() {
					var inlineMode = (editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE),
						plugin = CKEDITOR.plugins.scayt,
						scaytInstance = editor.scayt,
						text = inlineMode ? editor.container.getText() : editor.document.getBody().getText();

					text = text.replace(/\s/g, &#39;&#39;);

					if(text) {
						if(scaytInstance &amp;&amp; plugin.state[editor.name] &amp;&amp; scaytInstance.setMarkupPaused) {
							scaytInstance.setMarkupPaused(true);
						}

						editor.lockSelection();
						editor.execCommand(&#39;checkspell&#39;);
					} else {
						alert(&#39;Nothing to check!&#39;);
					}
				}
			}
		}

		editor.addMenuItems(uiMenuItems);
	},
	bindEvents: function(editor) {
		var self = this,
			plugin = CKEDITOR.plugins.scayt,
			inline_mode = (editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE);

		var scaytDestroy = function() {
			plugin.destroy(editor);
		};

		var contentDomReady = function() {
			// The event is fired when editable iframe node was reinited so we should restart our service
			if (plugin.state[editor.name] &amp;&amp; !editor.readOnly &amp;&amp; !editor.scayt) {
				plugin.createScayt(editor);
			}
		};

		var addMarkupStateHandlers = function() {
			var editable = editor.editable();

			editable.attachListener( editable, &#39;focus&#39;, function( evt ) {
				if( CKEDITOR.plugins.scayt &amp;&amp; !editor.scayt ) {
					setTimeout(contentDomReady, 0); // we need small timeout in order to correctly set initial &#39;focused&#39; option value in SCAYT core
				}

				var pluginStatus = CKEDITOR.plugins.scayt &amp;&amp; CKEDITOR.plugins.scayt.state[editor.name] &amp;&amp; editor.scayt,
					selectedElement, ranges, textLength, range;

				if((inline_mode ? true : pluginStatus) &amp;&amp; editor._.savedSelection) {
					selectedElement = editor._.savedSelection.getSelectedElement();
					ranges = !selectedElement &amp;&amp; editor._.savedSelection.getRanges();

					for(var i = 0; i &lt; ranges.length; i++) {
						range = ranges[i];
						// we need to check type of node value in order to avoid error in IE when accessing &#39;nodeValue&#39; property
						if(typeof range.startContainer.$.nodeValue === &#39;string&#39;) {
							textLength = range.startContainer.getText().length;
							if(textLength &lt; range.startOffset || textLength &lt; range.endOffset) {
								editor.unlockSelection(false);
							}
						}
					}
				}
			}, this, null, -10 );	// priority &quot;-10&quot; is set to call SCAYT CKEDITOR.editor#unlockSelection before CKEDITOR.editor#unlockSelection call
		};

		var contentDomHandler = function() {
			if(inline_mode) {
				editor.on(&#39;blur&#39;, scaytDestroy);
				editor.on(&#39;focus&#39;, contentDomReady);

				// We need to check if editor has focus(created) right now.
				// If editor is active - make attempt to create scayt
				if(editor.focusManager.hasFocus) {
					contentDomReady();
				}

			} else {
				contentDomReady();
			}

			addMarkupStateHandlers();
		};

		editor.on(&#39;contentDom&#39;, contentDomHandler);

		editor.on(&#39;beforeCommandExec&#39;, function(ev) {
			var scaytInstance;

			// TODO: after switching in source mode not recreate SCAYT instance, try to just rerun markuping to don&#39;t make requests to server
			if(ev.data.name in plugin.options.disablingCommandExec &amp;&amp; editor.mode == &#39;wysiwyg&#39;) {
				scaytInstance = editor.scayt;
				if(scaytInstance) {
					plugin.destroy(editor);
					editor.fire(&#39;scaytButtonState&#39;, CKEDITOR.TRISTATE_DISABLED);
				}
			} else if(ev.data.name === &#39;bold&#39; || ev.data.name === &#39;italic&#39; || ev.data.name === &#39;underline&#39; || ev.data.name === &#39;strike&#39; || ev.data.name === &#39;subscript&#39; || ev.data.name === &#39;superscript&#39; || ev.data.name === &#39;enter&#39;) {
				scaytInstance = editor.scayt;
				if(scaytInstance) {
					scaytInstance.removeMarkupInSelectionNode();
					setTimeout(function() {
						scaytInstance.fire(&#39;startSpellCheck&#39;);
					}, 0);
				}
			}
		});

		editor.on(&#39;beforeSetMode&#39;, function(ev) {
			var scaytInstance;
			// needed when we use:
			// CKEDITOR.instances.editor_ID.setMode(&quot;source&quot;)
			// CKEDITOR.instances.editor_ID.setMode(&quot;wysiwyg&quot;)
			// can&#39;t be implemented in editor.on(&#39;mode&#39;, function(ev) {});
			if (ev.data == &#39;source&#39;) {
				scaytInstance = editor.scayt;
				if(scaytInstance) {
					plugin.destroy(editor);
					editor.fire(&#39;scaytButtonState&#39;, CKEDITOR.TRISTATE_DISABLED);
				}

				// remove custom data from body, to prevent waste properties showing in IE8
				if(editor.document) { //GitHub #84 : make sure that document exists(e.g. when startup mode set to &#39;source&#39;)
					editor.document.getBody().removeAttribute(&#39;_jquid&#39;);
				}
			}
		});

		editor.on(&#39;afterCommandExec&#39;, function(ev) {
			var scaytInstance;

			if(editor.mode == &#39;wysiwyg&#39; &amp;&amp; (ev.data.name == &#39;undo&#39; || ev.data.name == &#39;redo&#39;)) {
				scaytInstance = editor.scayt;
				if(scaytInstance) {
					setTimeout(function() {
						scaytInstance.fire(&#39;startSpellCheck&#39;);
					}, 250);
				}
			}
		});

		// handle readonly changes
		editor.on(&#39;readOnly&#39;, function(ev) {
			var scaytInstance;

			if(ev) {
				scaytInstance = editor.scayt;

				if(ev.editor.readOnly === true) {
					if(scaytInstance) {
						scaytInstance.fire(&#39;removeMarkupInDocument&#39;, {});
					}
				} else {
					if(scaytInstance) {
						scaytInstance.fire(&#39;startSpellCheck&#39;);
					} else if(ev.editor.mode == &#39;wysiwyg&#39; &amp;&amp; plugin.state[ev.editor.name] === true) {
						plugin.createScayt(editor);
						ev.editor.fire(&#39;scaytButtonState&#39;, CKEDITOR.TRISTATE_ON);
					}
				}
			}
		});

		// we need to destroy SCAYT before CK editor will be completely destroyed
		editor.on(&#39;beforeDestroy&#39;, scaytDestroy);

		//#9439 after SetData method fires contentDom event and SCAYT create additional instanse
		// This way we should destroy SCAYT on setData event when contenteditable Iframe was re-created
		editor.on(&#39;setData&#39;, function() {
			scaytDestroy();

			// in inline mode SetData does not fire contentDom event
			if(editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE || editor.plugins.divarea) {
				contentDomHandler();
			}
		}, this, null, 50);

		function reloadMarkupScayt() {
			var scaytInstance = editor.scayt;

			if (scaytInstance) {
				scaytInstance.removeMarkupInSelectionNode();
				scaytInstance.fire(&#39;startSpellCheck&#39;);
			}
		}

		// Reload spell-checking for current word after insertion completed.
		editor.on(&#39;insertElement&#39;, function() {

			// IE bug: we need wait here to make sure that focus is returned to editor, and we can store the selection before we proceed with markup
			if ( CKEDITOR.env.ie ) {
				setTimeout(function() {
					reloadMarkupScayt();
				}, 50);
			} else {
				reloadMarkupScayt();
			}


		}, this, null, 50);

		editor.on(&#39;insertHtml&#39;, function() {
			reloadMarkupScayt();
		}, this, null, 50);

		editor.on(&#39;insertText&#39;, function() {
			reloadMarkupScayt();
		}, this, null, 50);

		// The event is listening to open necessary dialog tab
		editor.on(&#39;scaytDialogShown&#39;, function(ev) {
			var dialog = ev.data,
				scaytInstance = editor.scayt;

			dialog.selectPage(scaytInstance.tabToOpen);
		});

		editor.on(&#39;paste&#39;, function(ev) {
			var scaytInstance = editor.scayt;

			if(scaytInstance) {
				scaytInstance.removeMarkupInSelectionNode();
			}
		}, null, null, 0);
	},
	parseConfig: function(editor) {
		var plugin = CKEDITOR.plugins.scayt;

		// preprocess config for backward compatibility
		plugin.replaceOldOptionsNames(editor.config);

		// Checking editor&#39;s config after initialization
		if(typeof editor.config.scayt_autoStartup !== &#39;boolean&#39;) {
			editor.config.scayt_autoStartup = false;
		}
		plugin.state[editor.name] = editor.config.scayt_autoStartup;

		if(!editor.config.scayt_contextCommands) {
			editor.config.scayt_contextCommands = &#39;ignore|ignoreall|add&#39;;
		}

		if(!editor.config.scayt_contextMenuItemsOrder) {
			editor.config.scayt_contextMenuItemsOrder = &#39;suggest|moresuggest|control&#39;;
		}

		if(!editor.config.scayt_sLang) {
			editor.config.scayt_sLang = &#39;en_US&#39;;
		}

		if(editor.config.scayt_maxSuggestions === undefined || typeof editor.config.scayt_maxSuggestions != &#39;number&#39; || editor.config.scayt_maxSuggestions &lt; 0) {
			editor.config.scayt_maxSuggestions = 5;
		}

		if(editor.config.scayt_minWordLength === undefined || typeof editor.config.scayt_minWordLength != &#39;number&#39; || editor.config.scayt_minWordLength &lt; 1) {
			editor.config.scayt_minWordLength = 4;
		}

		if(editor.config.scayt_customDictionaryIds === undefined || typeof editor.config.scayt_customDictionaryIds !== &#39;string&#39;) {
			editor.config.scayt_customDictionaryIds = &#39;&#39;;
		}

		if(editor.config.scayt_userDictionaryName === undefined || typeof editor.config.scayt_userDictionaryName !== &#39;string&#39;) {
			editor.config.scayt_userDictionaryName = null;
		}

		if (typeof editor.config.scayt_uiTabs === &#39;string&#39; &amp;&amp; editor.config.scayt_uiTabs.split(&#39;,&#39;).length === 3) {
			var scayt_uiTabs = [], _tempUITabs = [];
			editor.config.scayt_uiTabs = editor.config.scayt_uiTabs.split(&#39;,&#39;);

			CKEDITOR.tools.search(editor.config.scayt_uiTabs, function(value) {
				if (Number(value) === 1 || Number(value) === 0) {
					_tempUITabs.push(true);
					scayt_uiTabs.push(Number(value));
				} else {
					_tempUITabs.push(false);
				}
			});

			if (CKEDITOR.tools.search(_tempUITabs, false) === null) {
				editor.config.scayt_uiTabs = scayt_uiTabs;
			} else {
				editor.config.scayt_uiTabs = [1,1,1];
			}

		} else {
			editor.config.scayt_uiTabs = [1,1,1];
		}

		if(typeof editor.config.scayt_serviceProtocol != &#39;string&#39;) {
			editor.config.scayt_serviceProtocol = null;
		}

		if(typeof editor.config.scayt_serviceHost != &#39;string&#39;) {
			editor.config.scayt_serviceHost = null;
		}

		if(typeof editor.config.scayt_servicePort != &#39;string&#39;) {
			editor.config.scayt_servicePort = null;
		}

		if(typeof editor.config.scayt_servicePath != &#39;string&#39;) {
			editor.config.scayt_servicePath = null;
		}

		if(!editor.config.scayt_moreSuggestions) {
			editor.config.scayt_moreSuggestions = &#39;on&#39;;
		}

		if(typeof editor.config.scayt_customerId !== &#39;string&#39;) {
			editor.config.scayt_customerId = &#39;1:WvF0D4-UtPqN1-43nkD4-NKvUm2-daQqk3-LmNiI-z7Ysb4-mwry24-T8YrS3-Q2tpq2&#39;;
		}

		if(typeof editor.config.scayt_srcUrl !== &#39;string&#39;) {
			var protocol = document.location.protocol;
			protocol = protocol.search(/https?:/) != -1 ? protocol : &#39;http:&#39;;

			editor.config.scayt_srcUrl = protocol + &#39;//svc.webspellchecker.net/spellcheck31/lf/scayt3/ckscayt/ckscayt.js&#39;;
		}

		if(typeof CKEDITOR.config.scayt_handleCheckDirty !== &#39;boolean&#39;) {
			CKEDITOR.config.scayt_handleCheckDirty = true;
		}

		if(typeof CKEDITOR.config.scayt_handleUndoRedo !== &#39;boolean&#39;) {
			CKEDITOR.config.scayt_handleUndoRedo = true;
		}

		if( editor.config.scayt_disableOptionsStorage ) {
			var userOptions = CKEDITOR.tools.isArray( editor.config.scayt_disableOptionsStorage ) ? editor.config.scayt_disableOptionsStorage : ( typeof editor.config.scayt_disableOptionsStorage === &#39;string&#39; ) ? [ editor.config.scayt_disableOptionsStorage ] : undefined,
				availableValue = [ &#39;all&#39;, &#39;options&#39;, &#39;lang&#39;, &#39;ignore-all-caps-words&#39;, &#39;ignore-domain-names&#39;, &#39;ignore-words-with-mixed-cases&#39;, &#39;ignore-words-with-numbers&#39;],
				valuesOption = [&#39;lang&#39;, &#39;ignore-all-caps-words&#39;, &#39;ignore-domain-names&#39;, &#39;ignore-words-with-mixed-cases&#39;, &#39;ignore-words-with-numbers&#39;],
				search = CKEDITOR.tools.search,
				indexOf = CKEDITOR.tools.indexOf;

			var isValidOption = function( option ) {
				return !!search( availableValue, option );
			};

			var makeOptionsToStorage = function( options ) {
				var retval = [];

				for (var i = 0; i &lt; options.length; i++) {
					var value = options[i],
						isGroupOptionInUserOptions = !!search( options, &#39;options&#39; );

					if( !isValidOption( value ) || isGroupOptionInUserOptions &amp;&amp; !!search( valuesOption, function( val ) { if( val === &#39;lang&#39; ) { return false; } } ) ) {
						return;
					}

					if( !!search( valuesOption, value ) ) {
						valuesOption.splice( indexOf( valuesOption, value ), 1 );
					}

					if(  value === &#39;all&#39; || isGroupOptionInUserOptions &amp;&amp; !!search( options, &#39;lang&#39; )) {
						return [];
					}

					if( value === &#39;options&#39; ) {
						valuesOption = [ &#39;lang&#39; ];
					}
				}

				retval = retval.concat( valuesOption );

				return retval;
			};

			editor.config.scayt_disableOptionsStorage = makeOptionsToStorage( userOptions );
		}
	},
	addRule: function(editor) {
		var dataProcessor = editor.dataProcessor,
			htmlFilter = dataProcessor &amp;&amp; dataProcessor.htmlFilter,
			pathFilters = editor._.elementsPath &amp;&amp; editor._.elementsPath.filters,
			dataFilter = dataProcessor &amp;&amp; dataProcessor.dataFilter,
			removeFormatFilter = editor.addRemoveFormatFilter,
			scaytFilter = function scaytFilter(element) {
				var plugin = CKEDITOR.plugins.scayt,
					scaytInstance = editor.scayt;

				if(scaytInstance &amp;&amp; element.hasAttribute(plugin.options.data_attribute_name)) {
					return false;
				}
			},
			removeFormatFilterTemplate = function(element) {
				var plugin = CKEDITOR.plugins.scayt,
					scaytInstance = editor.scayt,
					result = true;

				if(scaytInstance &amp;&amp; element.hasAttribute(plugin.options.data_attribute_name)) {
					result = false;
				}

				return result;
			};

		if(pathFilters) {
			pathFilters.push(scaytFilter);
		}

		if(dataFilter) {
			var dataFilterRules = {
				elements: {
					span: function(element) {

						var plugin = CKEDITOR.plugins.scayt;

						if(plugin &amp;&amp; plugin.state[editor.name] &amp;&amp; element.classes &amp;&amp; CKEDITOR.tools.search(element.classes, plugin.options.misspelled_word_class)) {

							if (element.classes &amp;&amp; element.parent.type === CKEDITOR.NODE_DOCUMENT_FRAGMENT) {
								delete element.attributes[&#39;style&#39;];
								delete element.name;
							} else {
								delete element.classes[CKEDITOR.tools.indexOf(element.classes, plugin.options.misspelled_word_class)];
							}

						}

						return element;
					}
				}
			};

			dataFilter.addRules(dataFilterRules);
		}

		if (htmlFilter) {
			var htmlFilterRules = {
				elements: {
					span: function(element) {
						var plugin = CKEDITOR.plugins.scayt;

						if(plugin &amp;&amp; plugin.state[editor.name] &amp;&amp; element.hasClass(plugin.options.misspelled_word_class) &amp;&amp; element.attributes[plugin.options.data_attribute_name]) {

							element.removeClass(plugin.options.misspelled_word_class);
							delete element.attributes[plugin.options.data_attribute_name];
							delete element.name;
						}

						return element;
					}
				}
			};

			htmlFilter.addRules(htmlFilterRules);
		}

		if(removeFormatFilter) {
			removeFormatFilter.call(editor, removeFormatFilterTemplate);
		}
	},
	scaytMenuDefinition: function(editor) {
		var self = this,
			plugin = CKEDITOR.plugins.scayt,
			scayt_instance =  editor.scayt;
		return {
			scayt_ignore: {
				label:  scayt_instance.getLocal(&#39;btn_ignore&#39;),
				group : &#39;scayt_control&#39;,
				order : 1,
				exec: function(editor) {
					var scaytInstance = editor.scayt;
					scaytInstance.ignoreWord();
				}
			},
			scayt_ignoreall: {
				label : scayt_instance.getLocal(&#39;btn_ignoreAll&#39;),
				group : &#39;scayt_control&#39;,
				order : 2,
				exec: function(editor) {
					var scaytInstance = editor.scayt;
					scaytInstance.ignoreAllWords();
				}
			},
			scayt_add: {
				label : scayt_instance.getLocal(&#39;btn_addWord&#39;),
				group : &#39;scayt_control&#39;,
				order : 3,
				exec : function(editor) {
					var scaytInstance = editor.scayt;

					// @TODO: We need to add set/restore bookmark logic to &#39;addWordToUserDictionary&#39; method inside dictionarymanager.
					// Timeout is used as tmp fix for IE9, when after hitting &#39;Add word&#39; menu item, document container was blurred.
					setTimeout(function() {
						scaytInstance.addWordToUserDictionary();
					}, 10);
				}
			},
			option:{
				label : scayt_instance.getLocal(&#39;btn_options&#39;),
				group : &#39;scayt_control&#39;,
				order : 4,
				exec: function(editor) {
					var scaytInstance = editor.scayt;

					scaytInstance.tabToOpen = &#39;options&#39;;
					editor.lockSelection();
					editor.openDialog(self.dialogName);
				},
				verification: function(editor) {
					return (editor.config.scayt_uiTabs[0] == 1) ? true : false;
				}
			},
			language: {
				label : scayt_instance.getLocal(&#39;btn_langs&#39;),
				group : &#39;scayt_control&#39;,
				order : 5,
				exec: function(editor) {
					var scaytInstance = editor.scayt;

					scaytInstance.tabToOpen = &#39;langs&#39;;
					editor.lockSelection();
					editor.openDialog(self.dialogName);
				},
				verification: function(editor) {
					return (editor.config.scayt_uiTabs[1] == 1) ? true : false;
				}
			},
			dictionary: {
				label : scayt_instance.getLocal(&#39;btn_dictionaries&#39;),
				group : &#39;scayt_control&#39;,
				order : 6,
				exec: function(editor) {
					var scaytInstance = editor.scayt;

					scaytInstance.tabToOpen = &#39;dictionaries&#39;;
					editor.lockSelection();
					editor.openDialog(self.dialogName);
				},
				verification: function(editor) {
					return (editor.config.scayt_uiTabs[2] == 1) ? true : false;
				}
			},
			about: {
				label : scayt_instance.getLocal(&#39;btn_about&#39;),
				group : &#39;scayt_control&#39;,
				order : 7,
				exec: function(editor) {
					var scaytInstance = editor.scayt;

					scaytInstance.tabToOpen = &#39;about&#39;;
					editor.lockSelection();
					editor.openDialog(self.dialogName);
				}
			}
		};
	},
	buildSuggestionMenuItems: function(editor, suggestions) {
		var self = this,
			itemList = {},
			subItemList = {},
			plugin = CKEDITOR.plugins.scayt,
			scayt_instance = editor.scayt;

		if(suggestions.length &gt; 0 &amp;&amp; suggestions[0] !== &#39;no_any_suggestions&#39;) {
			for(var i = 0; i &lt; suggestions.length; i++) {

				var commandName = &#39;scayt_suggest_&#39; + CKEDITOR.plugins.scayt.suggestions[i].replace(&#39; &#39;, &#39;_&#39;);
				editor.addCommand(commandName, self.createCommand(CKEDITOR.plugins.scayt.suggestions[i]));

				if(i &lt; editor.config.scayt_maxSuggestions) {

					// mainSuggestions
					editor.addMenuItem(commandName, {
						label: suggestions[i],
						command: commandName,
						group: &#39;scayt_suggest&#39;,
						order: i + 1
					});

					itemList[commandName] = CKEDITOR.TRISTATE_OFF;

				} else {

					// moreSuggestions
					editor.addMenuItem(commandName, {
						label: suggestions[i],
						command: commandName,
						group: &#39;scayt_moresuggest&#39;,
						order: i + 1
					});

					subItemList[commandName] = CKEDITOR.TRISTATE_OFF;

					if(editor.config.scayt_moreSuggestions === &#39;on&#39;) {

						editor.addMenuItem(&#39;scayt_moresuggest&#39;, {
							label : scayt_instance.getLocal(&#39;btn_moreSuggestions&#39;),
							group : &#39;scayt_moresuggest&#39;,
							order : 10,
							getItems : function() {
								return subItemList;
							}
						});

						itemList[&#39;scayt_moresuggest&#39;] = CKEDITOR.TRISTATE_OFF;
					}
				}
			}
		} else {
			var noSuggestionsCommand = &#39;no_scayt_suggest&#39;;
			itemList[noSuggestionsCommand] = CKEDITOR.TRISTATE_DISABLED;

			editor.addCommand(noSuggestionsCommand, {
				exec: function() {

				}
			});

			editor.addMenuItem(noSuggestionsCommand, {
				label : scayt_instance.getLocal(&#39;btn_noSuggestions&#39;) || noSuggestionsCommand,
				command: noSuggestionsCommand,
				group : &#39;scayt_suggest&#39;,
				order : 0
			});
		}

		return itemList;
	},
	menuGenerator: function(editor, word) {
		var self = this,
			scaytInstance = editor.scayt,
			menuItem = this.scaytMenuDefinition(editor),
			itemList = {},
			allowedOption = editor.config.scayt_contextCommands.split(&#39;|&#39;);

		scaytInstance.fire(&#39;getSuggestionsList&#39;, {lang: scaytInstance.getLang(), word: word});
		itemList = this.buildSuggestionMenuItems(editor, CKEDITOR.plugins.scayt.suggestions);

		if(editor.config.scayt_contextCommands == &#39;off&#39;) {
			return itemList;
		}

		for(var key in menuItem) {
			if(CKEDITOR.tools.indexOf(allowedOption, key.replace(&#39;scayt_&#39;, &#39;&#39;)) == -1 &amp;&amp; editor.config.scayt_contextCommands != &#39;all&#39;) {
				continue;
			}

			itemList[key] = CKEDITOR.TRISTATE_OFF;
			// delete item from context menu if its state isn&#39;t verified as allowed
			if(typeof menuItem[key].verification === &#39;function&#39; &amp;&amp; !menuItem[key].verification(editor)) {
				// itemList[key] = (menuItem[key].verification(editor)) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
				delete itemList[key];
			}

			editor.addCommand(key, {
				exec: menuItem[key].exec
			});

			editor.addMenuItem(key, {
				label : editor.lang.scayt[menuItem[key].label] || menuItem[key].label,
				command: key,
				group : menuItem[key].group,
				order : menuItem[key].order
			});
		}

		return itemList;
	},
	createCommand: function(suggestion) {
		return {
			exec: function(editor) {
				var scaytInstance = editor.scayt;
				scaytInstance.replaceSelectionNode({word: suggestion});
			}
		};
	}
});

CKEDITOR.plugins.scayt = {
	state: {},
	suggestions: [],
	loadingHelper: {
		loadOrder: []
	},
	isLoading: false,
	options: {
		disablingCommandExec: {
			source: true,
			newpage: true,
			templates: true
		},
		data_attribute_name: &#39;data-scayt-word&#39;,
		misspelled_word_class: &#39;scayt-misspell-word&#39;
	},
	backCompatibilityMap: {
		&#39;scayt_service_protocol&#39;: &#39;scayt_serviceProtocol&#39;,
		&#39;scayt_service_host&#39;  : &#39;scayt_serviceHost&#39;,
		&#39;scayt_service_port&#39;  : &#39;scayt_servicePort&#39;,
		&#39;scayt_service_path&#39;  : &#39;scayt_servicePath&#39;,
		&#39;scayt_customerid&#39;    : &#39;scayt_customerId&#39;
	},
	replaceOldOptionsNames: function(config) {
		for(var key in config) {
			if(key in this.backCompatibilityMap) {
				config[this.backCompatibilityMap[key]] = config[key];
				delete config[key];
			}
		}
	},
	createScayt : function(editor) {
		var self = this;

		this.loadScaytLibrary(editor, function(_editor) {
			var _scaytInstanceOptions = {
				lang 				: _editor.config.scayt_sLang,
				container 			: _editor.editable().$.nodeName == &#39;BODY&#39; ? _editor.document.getWindow().$.frameElement : _editor.editable().$,
				customDictionary 	: _editor.config.scayt_customDictionaryIds,
				userDictionaryName 	: _editor.config.scayt_userDictionaryName,
				localization 		: _editor.langCode,
				customer_id 		: _editor.config.scayt_customerId,
				debug 				: _editor.config.scayt_debug,
				data_attribute_name : self.options.data_attribute_name,
				misspelled_word_class: self.options.misspelled_word_class,
				&#39;options-to-restore&#39;:  _editor.config.scayt_disableOptionsStorage,
				focused 			: _editor.editable().hasFocus, // #30260 we need to set focused=true if CKEditor is focused before SCAYT initialization
				ignoreElementsRegex : _editor.config.scayt_elementsToIgnore,
				minWordLength 		: _editor.config.scayt_minWordLength
			};

			if(_editor.config.scayt_serviceProtocol) {
				_scaytInstanceOptions[&#39;service_protocol&#39;] = _editor.config.scayt_serviceProtocol;
			}

			if(_editor.config.scayt_serviceHost) {
				_scaytInstanceOptions[&#39;service_host&#39;] = _editor.config.scayt_serviceHost;
			}

			if(_editor.config.scayt_servicePort) {
				_scaytInstanceOptions[&#39;service_port&#39;] = _editor.config.scayt_servicePort;
			}

			if(_editor.config.scayt_servicePath) {
				_scaytInstanceOptions[&#39;service_path&#39;] = _editor.config.scayt_servicePath;
			}

			var _scaytInstance = new SCAYT.CKSCAYT(_scaytInstanceOptions, function() {
					// success callback
				}, function() {
					// error callback
				}),
				wordsPrefix = &#39;word_&#39;;

			_scaytInstance.subscribe(&#39;suggestionListSend&#39;, function(data) {
				// TODO: 1. Maybe store suggestions for specific editor
				// TODO: 2. Fix issue with suggestion duplicates on on server
				//CKEDITOR.plugins.scayt.suggestions = data.suggestionList;
				var _wordsCollection = {},
					_suggestionList =[];

				for (var i = 0; i &lt; data.suggestionList.length; i++) {
					if (!_wordsCollection[wordsPrefix + data.suggestionList[i]]) {
						_wordsCollection[wordsPrefix + data.suggestionList[i]] = data.suggestionList[i];
						_suggestionList.push(data.suggestionList[i]);
					}
				}

				CKEDITOR.plugins.scayt.suggestions = _suggestionList;
			});

			// if selection has changed programmatically by SCAYT we need to react appropriately
			_scaytInstance.subscribe(&#39;selectionIsChanged&#39;, function(data) {
				var selection = _editor.getSelection();

				if(selection.isLocked) {
					_editor.lockSelection();
				}
			});

			_editor.scayt = _scaytInstance;

			_editor.fire(&#39;scaytButtonState&#39;, _editor.readOnly ? CKEDITOR.TRISTATE_DISABLED : CKEDITOR.TRISTATE_ON);
		});
	},
	destroy: function(editor) {
		if(editor.scayt) {
			editor.scayt.destroy();
		}

		delete editor.scayt;
		editor.fire(&#39;scaytButtonState&#39;, CKEDITOR.TRISTATE_OFF);
	},
	loadScaytLibrary: function(editor, callback) {
		var self = this,
			date,
			timestamp,
			scaytUrl;

		if(typeof window.SCAYT === &#39;undefined&#39; || typeof window.SCAYT.CKSCAYT !== &#39;function&#39;) {
			// no need to process load requests from same editor as it can cause bugs with
			// loading ckscayt app due to subsequent calls of some events
			if(this.loadingHelper[editor.name]) return;

			// add onLoad callbacks for editors while SCAYT is loading
			this.loadingHelper[editor.name] = callback;
			this.loadingHelper.loadOrder.push(editor.name);

			//creating unique timestamp for SCAYT URL
			date = new Date();
			timestamp = date.getTime();
			scaytUrl = editor.config.scayt_srcUrl + &#39;?&#39; + timestamp;

			CKEDITOR.scriptLoader.load(scaytUrl, function(success) {
				var editorName;

				CKEDITOR.fireOnce(&#39;scaytReady&#39;);

				for(var i = 0; i &lt; self.loadingHelper.loadOrder.length; i++) {
					editorName = self.loadingHelper.loadOrder[i];

					if(typeof self.loadingHelper[editorName] === &#39;function&#39;) {
						self.loadingHelper[editorName](CKEDITOR.instances[editorName]);
					}

					delete self.loadingHelper[editorName];
				}
				self.loadingHelper.loadOrder = [];
			});
		} else if(window.SCAYT &amp;&amp; typeof window.SCAYT.CKSCAYT === &#39;function&#39;) {
			CKEDITOR.fireOnce(&#39;scaytReady&#39;);

			if(!editor.scayt) {
				if(typeof callback === &#39;function&#39;) {
					callback(editor);
				}
			}
		}
	}
};

CKEDITOR.on(&#39;dialogDefinition&#39;, function(dialogDefinitionEvent) {

	if (dialogDefinitionEvent.data.name === &#39;scaytDialog&#39;) {

		var dialogDefinition = dialogDefinitionEvent.data.definition;

		dialogDefinition.dialog.on(&#39;cancel&#39;, function(cancelEvent) {
			return false;
		}, this, null, -1);
	}
});

CKEDITOR.on(&#39;scaytReady&#39;, function() {

	// Override editor.checkDirty method avoid CK checkDirty functionality to fix SCAYT issues with incorrect checkDirty behavior.
	if(CKEDITOR.config.scayt_handleCheckDirty === true) {
		var editorCheckDirty = CKEDITOR.editor.prototype;

		editorCheckDirty.checkDirty = CKEDITOR.tools.override(editorCheckDirty.checkDirty, function(org) {

			return function() {
				var retval = null,
					pluginStatus = CKEDITOR.plugins.scayt &amp;&amp; CKEDITOR.plugins.scayt.state[this.name] &amp;&amp; this.scayt,
					scaytInstance = this.scayt;

				if(!pluginStatus) {
					retval = org.call(this);
				} else {
					retval = (this.status == &#39;ready&#39;);

					if (retval) {
						var currentData = scaytInstance.removeMarkupFromString(this.getSnapshot()),
							prevData = scaytInstance.removeMarkupFromString(this._.previousValue);

						retval = (retval &amp;&amp; (prevData !== currentData))
					}
				}

				return retval;
			};
		});

		editorCheckDirty.resetDirty = CKEDITOR.tools.override(editorCheckDirty.resetDirty, function(org) {
			return function() {
				var pluginStatus = CKEDITOR.plugins.scayt &amp;&amp; CKEDITOR.plugins.scayt.state[this.name] &amp;&amp; this.scayt,
					scaytInstance = this.scayt;//CKEDITOR.plugins.scayt.getScayt(this);

				if(!pluginStatus) {
					org.call(this);
				} else {
					this._.previousValue = scaytInstance.removeMarkupFromString(this.getSnapshot());
				}
			};
		});
	}

	if(CKEDITOR.config.scayt_handleUndoRedo === true) {
		var undoImagePrototype = CKEDITOR.plugins.undo.Image.prototype;

		// add backword compatibility for CKEDITOR 4.2. method equals was repleced on other method
		var equalsContentMethodName = (typeof undoImagePrototype.equalsContent == &quot;function&quot;) ? &#39;equalsContent&#39; : &#39;equals&#39;;

		undoImagePrototype[equalsContentMethodName] = CKEDITOR.tools.override(undoImagePrototype[equalsContentMethodName], function(org) {
			return function(otherImage) {
				var pluginState = CKEDITOR.plugins.scayt &amp;&amp; CKEDITOR.plugins.scayt.state[otherImage.editor.name] &amp;&amp; otherImage.editor.scayt,
					scaytInstance = otherImage.editor.scayt,
					thisContents = this.contents,
					otherContents = otherImage.contents,
					retval = null;

				// Making the comparison based on content without SCAYT word markers.
				if(pluginState) {
					this.contents = scaytInstance.removeMarkupFromString(thisContents) || &#39;&#39;;
					otherImage.contents = scaytInstance.removeMarkupFromString(otherContents) || &#39;&#39;;
				}

				var retval = org.apply(this, arguments);

				this.contents = thisContents;
				otherImage.contents = otherContents;

				return retval;
			};
		});
	}
});

<span id='CKEDITOR-config-cfg-scayt_autoStartup'>/**
</span> * The parameter turns on/off SCAYT on the autostartup. If &#39;true&#39;, turns on SCAYT automatically after loading the editor.
 *
 *		config.scayt_autoStartup = true;
 *
 * @cfg {Boolean} [scayt_autoStartup=false]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_maxSuggestions'>/**
</span> * The parameter defines the number of SCAYT suggestions to show in the main context menu.
 * Possible values are:
 *
 * * `0` (zero) &amp;ndash; No suggestions are shown in the main context menu. All
 *     entries will be listed in the &quot;More Suggestions&quot; sub-menu.
 * * Positive number &amp;ndash; The maximum number of suggestions to show in the context
 *     menu. Other entries will be shown in the &quot;More Suggestions&quot; sub-menu.
 * * Negative number &amp;ndash; 5 suggestions are shown in the main context menu. All other
 *     entries will be listed in the &quot;More Suggestions&quot; sub-menu.
 *
 * Examples:
 *
 *		// Display only three suggestions in the main context menu.
 *		config.scayt_maxSuggestions = 3;
 *
 *		// Do not show the suggestions directly.
 *		config.scayt_maxSuggestions = 0;
 *
 * @cfg {Number} [scayt_maxSuggestions=5]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_minWordLength'>/**
</span> * The parameter defines minimum length of the words that will be collected from editor&#39;s text for spell checking.
 * Possible value is any positive number.
 *
 * Examples:
 *
 *		// Set minimum length of the words that will be collected from text.
 *		config.scayt_minWordLength = 5;
 *
 * @cfg {Number} [scayt_minWordLength=4]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_customerId'>/**
</span> * The parameter sets the customer ID for SCAYT. Used for hosted users only. Required for migration from free
 * to trial or paid versions.
 *
 *		// Load SCAYT using my customer ID.
 *		config.scayt_customerId  = &#39;your-encrypted-customer-id&#39;;
 *
 * @cfg {String} [scayt_customerId=&#39;1:WvF0D4-UtPqN1-43nkD4-NKvUm2-daQqk3-LmNiI-z7Ysb4-mwry24-T8YrS3-Q2tpq2&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_moreSuggestions'>/**
</span> * The parameter enables/disables the &quot;More Suggestions&quot; sub-menu in the context menu.
 * Possible values are `&#39;on&#39;` and `&#39;off&#39;`.
 *
 *		// Disables the &quot;More Suggestions&quot; sub-menu.
 *		config.scayt_moreSuggestions = &#39;off&#39;;
 *
 * @cfg {String} [scayt_moreSuggestions=&#39;on&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_contextCommands'>/**
</span> * The parameter customizes the display of SCAYT context menu commands (&quot;Add Word&quot;, &quot;Ignore&quot;,
 * &quot;Ignore All&quot;, &quot;Options&quot;, &quot;Languages&quot;, &quot;Dictionaries&quot; and &quot;About&quot;).
 * This must be a string with one or more of the following
 * words separated by a pipe character (`&#39;|&#39;`):
 *
 * * `off` &amp;ndash; disables all options.
 * * `all` &amp;ndash; enables all options.
 * * `ignore` &amp;ndash; enables the &quot;Ignore&quot; option.
 * * `ignoreall` &amp;ndash; enables the &quot;Ignore All&quot; option.
 * * `add` &amp;ndash; enables the &quot;Add Word&quot; option.
 * * `option` &amp;ndash; enables &quot;Options&quot; menu item.
 * * `language` &amp;ndash; enables &quot;Languages&quot; menu item.
 * * `dictionary` &amp;ndash; enables &quot;Dictionaries&quot; menu item.
 * * `about` &amp;ndash; enables &quot;About&quot; menu item.
 *
 * Note, that availability of &#39;Options&#39;, &#39;Languages&#39; and &#39;Dictionaries&#39; items
 * depends on scayt_uiTabs option also.
 * Example:
 *
 *		// Show only &quot;Add Word&quot; and &quot;Ignore All&quot; in the context menu.
 *		config.scayt_contextCommands = &#39;add|ignoreall&#39;;
 *
 * @cfg {String} [scayt_contextCommands=&#39;ignore|ignoreall|add&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_sLang'>/**
</span> * The parameter sets the default spell checking language for SCAYT. Possible values are:
 * `&#39;en_US&#39;`, `&#39;en_GB&#39;`, `&#39;pt_BR&#39;`, `&#39;da_DK&#39;`,
 * `&#39;nl_NL&#39;`, `&#39;en_CA&#39;`, `&#39;fi_FI&#39;`, `&#39;fr_FR&#39;`,
 * `&#39;fr_CA&#39;`, `&#39;de_DE&#39;`, `&#39;el_GR&#39;`, `&#39;it_IT&#39;`,
 * `&#39;nb_NO&#39;`, `&#39;pt_PT&#39;`, `&#39;es_ES&#39;`, `&#39;sv_SE&#39;`.
 *
 *		// Sets SCAYT to German.
 *		config.scayt_sLang = &#39;de_DE&#39;;
 *
 * @cfg {String} [scayt_sLang=&#39;en_US&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_uiTabs'>/**
</span> * The parameter customizes the SCAYT dialog and SCAYT toolbar menu to show particular tabs/items.
 * This setting must contain a `1` (enabled) or `0`
 * (disabled) value for each of the following entries, in this precise order,
 * separated by a comma (`&#39;,&#39;`): `&#39;Options&#39;`, `&#39;Languages&#39;`, and `&#39;Dictionary&#39;`.
 *
 *		// Hides the &quot;Languages&quot; tab.
 *		config.scayt_uiTabs = &#39;1,0,1&#39;;
 *
 * @cfg {String} [scayt_uiTabs=&#39;1,1,1&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_serviceProtocol'>/**
</span> * The parameter allows to specify protocol for WSC service (ssrv.cgi) full path.
 *
 *		// Defines protocol for WSC service (ssrv.cgi) full path.
 *		config.scayt_serviceProtocol = &#39;https&#39;;
 *
 * @cfg {String} [scayt_serviceProtocol=&#39;http&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_serviceHost'>/**
</span> * The parameter allows to specify host for WSC service (ssrv.cgi) full path.
 *
 *		// Defines host for WSC service (ssrv.cgi) full path.
 *		config.scayt_serviceHost = &#39;my-host&#39;;
 *
 * @cfg {String} [scayt_serviceHost=&#39;svc.webspellchecker.net&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_servicePort'>/**
</span> * The parameter allows to specify port for WSC service (ssrv.cgi) full path.
 *
 *		// Defines port for WSC service (ssrv.cgi) full path.
 *		config.scayt_servicePort = &#39;2330&#39;;
 *
 * @cfg {String} [scayt_servicePort=&#39;80&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_servicePath'>/**
</span> * The parameter allows to specify path for WSC service (ssrv.cgi) full path.
 *
 *		// Defines host for WSC service (ssrv.cgi) full path.
 *		config.scayt_servicePath = &#39;my-path/ssrv.cgi&#39;;
 *
 * @cfg {String} [scayt_servicePath=&#39;spellcheck31/script/ssrv.cgi&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_srcUrl'>/**
</span> * The parameter sets the URL to SCAYT core. Required to switch to the licensed version of SCAYT application.
 *
 * Further details available at [http://wiki.webspellchecker.net/doku.php?id=migration:hosredfreetolicensedck](http://wiki.webspellchecker.net/doku.php?id=migration:hosredfreetolicensedck)
 *
 *		config.scayt_srcUrl = &quot;http://my-host/spellcheck/lf/scayt/scayt.js&quot;;
 *
 * @cfg {String} [scayt_srcUrl=&#39;//svc.webspellchecker.net/spellcheck31/lf/scayt3/ckscayt/ckscayt.js&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_customDictionaryIds'>/**
</span> * The parameter links SCAYT to custom dictionaries. This is a string containing dictionary IDs
 * separated by commas (`&#39;,&#39;`). Available only for the licensed version.
 *
 * Further details at [http://wiki.webspellchecker.net/doku.php?id=installationandconfiguration:customdictionaries:licensed](http://wiki.webspellchecker.net/doku.php?id=installationandconfiguration:customdictionaries:licensed)
 *
 *		config.scayt_customDictionaryIds = &#39;3021,3456,3478&#39;;
 *
 * @cfg {String} [scayt_customDictionaryIds=&#39;&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_userDictionaryName'>/**
</span> * The parameter activates a User Dictionary in SCAYT. The user
 * dictionary name must be used. Available only for the licensed version.
 *
 *		config.scayt_userDictionaryName = &#39;MyDictionary&#39;;
 *
 * @cfg {String} [scayt_userDictionaryName=&#39;&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_contextMenuItemsOrder'>/**
</span> * The parameter defines the order SCAYT context menu items by groups.
 * This must be a string with one or more of the following
 * words separated by a pipe character (`&#39;|&#39;`):
 *
 * * `suggest` &amp;ndash; main suggestion word list,
 * * `moresuggest` &amp;ndash; more suggestions word list,
 * * `control` &amp;ndash; SCAYT commands, such as &quot;Ignore&quot; and &quot;Add Word&quot;.
 *
 * Example:
 *
 *		config.scayt_contextMenuItemsOrder = &#39;moresuggest|control|suggest&#39;;
 *
 * @cfg {String} [scayt_contextMenuItemsOrder=&#39;suggest|moresuggest|control&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_handleCheckDirty'>/**
</span> * If set to `true` &amp;ndash; overrides checkDirty functionality of CK
 * to fix SCAYT issues with incorrect checkDirty behavior. If set to `false`,
 * provides better performance on big preloaded text.
 *
 *		config.scayt_handleCheckDirty = &#39;false&#39;;
 *
 * @cfg {String} [scayt_handleCheckDirty=&#39;true&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_handleUndoRedo'>/**
</span> * If set to `true` &amp;ndash; overrides undo\redo functionality of CK
 * to fix SCAYT issues with incorrect undo\redo behavior. If set to `false`,
 * provides better performance on undo\redo text.
 *
 *		config.scayt_handleUndoRedo = &#39;false&#39;;
 *
 * @cfg {String} [scayt_handleUndoRedo=&#39;true&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_disableOptionsStorage'>/**
</span> * Disabling of SCAYT Options storing during several sessions. Options storing will be turned off after page refresh.
 *
 * * `&#39;options&#39;` - disables all SCAYT Ignore options
 * * `&#39;ignore-all-caps-words&#39;` - disables &#39;Ignore All-Caps Words&#39; option
 * * `&#39;ignore-domain-names&#39;` - disables &#39;Ignore Domain Names&#39; option
 * * `&#39;ignore-words-with-mixed-cases&#39;` - disables &#39;Ignore Words with Mixed Case&#39; option
 * * `&#39;ignore-words-with-numbers&#39;` - disables &#39;Ignore Words with Numbers&#39; option
 * * `&#39;lang&#39;` - disables SCAYT spell check language storing
 * * `&#39;all&#39;` - disables all SCAYT options storing
 *
 * Example:
 *
 *		// One options disabling.
 *		config.scayt_disableOptionsStorage = &#39;all&#39;;
 *
 *		// Several options disabling.
 *  	config.scayt_disableOptionsStorage = [&#39;lang&#39;, &#39;ignore-domain-names&#39;, &#39;ignore-words-with-numbers&#39;];
 *
 *
 * @cfg {String|Array} [scayt_disableOptionsStorage =&#39;&#39;]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-scayt_elementsToIgnore'> /**
</span> * Specifies the names of tags that will be skipped while spell checking. This is a string containing tag names
 * separated by commas (`&#39;,&#39;`). Please note that `&#39;style&#39;` tag would be added to specified tags list.
 *
 *		config.scayt_elementsToIgnore = &#39;del,pre&#39;;
 *
 * @cfg {String} [scayt_elementsToIgnore=&#39;style&#39;]
 * @member CKEDITOR.config
 */
</pre>
</body>
</html>
